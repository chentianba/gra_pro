!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	test.c	/^uint32_t A[N];$/;"	v
BURST_SIZE	main.c	52;"	d	file:
COMMENT_LEAD_CHAR	main.c	59;"	d	file:
FLOW_CLASSIFIER_NAME_SIZE	main.c	57;"	d	file:
FLOW_CLASSIFY_MAX_PRIORITY	main.c	56;"	d	file:
FLOW_CLASSIFY_MAX_RULE_NUM	main.c	55;"	d	file:
MAX_NUM_CLASSIFY	main.c	54;"	d	file:
MBUF_CACHE_SIZE	main.c	51;"	d	file:
N	test.c	10;"	d	file:
NUM_MBUFS	main.c	50;"	d	file:
OPTION_RULE_IPV4	main.c	60;"	d	file:
RTE_LOGTYPE_FLOW_CLASSIFY	main.c	61;"	d	file:
RX_RING_SIZE	main.c	47;"	d	file:
TX_RING_SIZE	main.c	48;"	d	file:
__cf_swap	cuckoo_filter.c	/^uint32_t __cf_swap(uint8_t *data1, uint8_t *data2, uint32_t len) {$/;"	f
add_rule	main.c	/^add_rule(struct rte_eth_ntuple_filter *ntuple_filter)$/;"	f	file:
bf_clear	bloom_filter.c	/^uint32_t bf_clear(struct bloom_filter* bf, uint32_t index) {$/;"	f
bf_init	bloom_filter.c	/^struct bloom_filter* bf_init(uint32_t bf_sz, uint32_t nb_hash) {$/;"	f
bf_insert	bloom_filter.c	/^uint32_t bf_insert(struct bloom_filter *bf, uint8_t *key, uint32_t klen) {$/;"	f
bf_lookup	bloom_filter.c	/^uint32_t bf_lookup(struct bloom_filter *bf, uint8_t *key, uint32_t klen) {$/;"	f
bf_print	bloom_filter.c	/^uint32_t bf_print(struct bloom_filter* bf) {$/;"	f
bf_set	bloom_filter.c	/^uint32_t bf_set(struct bloom_filter* bf, uint32_t index) {$/;"	f
cf_bucket_empty	cuckoo_filter.c	/^uint32_t cf_bucket_empty(struct cuckoo_filter *cf, uint32_t idx) {$/;"	f
cf_cmp_eq	cuckoo_filter.c	/^uint32_t cf_cmp_eq(uint8_t *data1, uint8_t *data2, uint32_t len) {$/;"	f
cf_delete	cuckoo_filter.c	/^uint32_t cf_delete(struct cuckoo_filter *cf, uint8_t *key, uint32_t klen) {$/;"	f
cf_fingerprint	cuckoo_filter.c	/^fp_ptr cf_fingerprint(struct hash_table *ht, uint8_t *data,$/;"	f
cf_hash	cuckoo_filter.c	/^uint32_t cf_hash(struct hash_table *ht, uint8_t *data,$/;"	f
cf_init	cuckoo_filter.c	/^struct cuckoo_filter* cf_init(struct hash_table_param *ht_param) {$/;"	f
cf_insert	cuckoo_filter.c	/^uint32_t cf_insert(struct cuckoo_filter *cf, uint8_t *key, uint32_t klen) {$/;"	f
cf_lookup	cuckoo_filter.c	/^uint32_t cf_lookup(struct cuckoo_filter *cf, uint8_t *key, uint32_t klen) {$/;"	f
debug_print	cuckoo_filter.c	/^uint32_t debug_print(struct hash_table *ht) {$/;"	f
flow_classify_log	main.c	62;"	d	file:
g_fingerprint	cuckoo_filter.c	/^uint8_t g_fingerprint;$/;"	v
g_pri_idx	cuckoo_filter.c	/^uint32_t g_pri_idx, g_sec_idx;$/;"	v
g_sec_idx	cuckoo_filter.c	/^uint32_t g_pri_idx, g_sec_idx;$/;"	v
ht_delete	cuckoo_filter.c	/^uint32_t ht_delete(struct hash_table *ht) {$/;"	f
ht_init	cuckoo_filter.c	/^struct hash_table *ht_init(uint32_t max_len, uint32_t nb_bkt,$/;"	f
is_matched_rule	main.c	/^is_matched_rule(struct rte_eth_ntuple_filter *one,$/;"	f	file:
lcore_main	main.c	/^lcore_main()$/;"	f	file:
lookup_rule	main.c	/^lookup_rule(struct rte_eth_ntuple_filter *ntuple_filter) {$/;"	f	file:
main	main.c	/^main(int argc, char *argv[])$/;"	f
main	test.c	/^int main() {$/;"	f
num_classify_rules	main.c	/^static int num_classify_rules;$/;"	v	file:
parse_args	main.c	/^parse_args(int argc, char **argv)$/;"	f	file:
port_conf_default	main.c	/^static const struct rte_eth_conf port_conf_default = {$/;"	v	typeref:struct:rte_eth_conf	file:
port_init	main.c	/^port_init(uint8_t port, struct rte_mempool *mbuf_pool)$/;"	f	file:
query_rules	main.c	/^query_rules(struct rte_mbuf *buf) {$/;"	f	file:
rules	main.c	/^static struct rte_eth_ntuple_filter rules[MAX_NUM_CLASSIFY];$/;"	v	typeref:struct:rte_eth_ntuple_filter	file:
set_rules	main.c	/^set_rules() {$/;"	f	file:
uint32_t_to_char	main.c	65;"	d	file:
